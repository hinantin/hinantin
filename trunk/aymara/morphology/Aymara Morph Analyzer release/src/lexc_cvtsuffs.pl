#!/usr/bin/env perl

##########################################################################
#
#	lexc_cvtsuffs.pl    convert various suffix xml files to lexc form
#
#       Ken Beesley
#	Copyright (c) 1999 2000 2005 Xerox Corporation.  All Rights Reserved.
#
#       modified 14 Feb 2000 for a more HVY-like analysis
#       modified 20 Mar 2000 to generate vcg file (graph)
#       Start modification for Unicode and XML::Twig 6 April 2005
#
#
##########################################################################

use strict ;
use XML::Twig ;
use Unicode::Normalize ;

my $suffdicsdir = "dic/suffixes" ;     # where the xml suffix-class files are stored

my $parser = new XML::Twig ( TwigHandlers => { 'suffdict' => \&suffdict_handler} ) ;

#############################################################################

# create a file just for the Multichar_Symbols declaration

# flag dicritics from roots.xml already listed in mcs.list; append to them
open MCOUT, ">>:utf8", "../obj/mcs.list" || die "Cannot open output file mcs.lexc." ;

# after all flag diacritics and other multichar symbols are listed in MCOUT,
#   the Makefile will sort and uniq it, adding "Multichar_Symbols" to the top

# create another lexc-format file for the various suffix LEXICONs

open LEXCOUT, ">:utf8", "../obj/suffs.lexc" || die "Cannot open output file suffs.lexc." ;
print LEXCOUT "! Generated by aymara/morph/src/lexc_cvtsuffs.pl\n" ;
print LEXCOUT "! Do not edit this file by hand.\n" ;

# lexc_cvtroots.pl has created various LEXICON files already in ../obj/
# for the various cat entries in roots.xml

# mcs.lex suffs.lex and then the various root LEXICONs will be cat-ed
# together in the Makefile to create a single lexc source file

# new output file for the VCG specification

open VCGOUT, ">:utf8", "../obj/aymara.vcg" || die "Cannot open output file aymara.vcg." ;
# print VCGOUT "display_edge_labels:yes\n\n" ;
print VCGOUT "graph:{\n\ntitle:\"aymara\"\norientation:left_to_right\n" ;
print VCGOUT "xspace:70\nmanhattan_edges:yes\nnode.borderwidth:3\nedge.thickness:3\n\n" ;


#############################################################################
#
#   The following function calls simultaneously build the suffs.lexc file
#   and the aymara.vcg source file, so that the diagram is always in sync
#   with the lexc file.
#
#   In other words, the LEXC morphotactics really gets described right here
#   in the Perl script
#
#############################################################################

&dobranch("Root",

	  "adjective",  # scripts produce LEXICON adjective separately; with each
                        #   entry leading to LEXICON adjectiveroot (same for below)
	  "dayname",
	  "digit",
	  "interrogative",
	  "monthname",
	  "multiplier",
	  "negative",
	  "ntemporal",
	  "positional",
	  "positionaldefective",
	  "pronoundemonstrative",
	  "pronounpersonal",
	  "nproper",
	  "ncommon",
	  "verb",
	  "nounguess",           # guesses new 16 Oct 2000
	  "verbguess") ;         # guesses new 16 Oct 2000


# Create a LEXICON nounguess
# with a single entry that is nothing but a placeholder

# new 16 Oct 2000
open NGOUT, ">:utf8", "../obj/nounguess.lexc" || die "Couldn't open obj/nounguess.lexc" ;
print NGOUT "\nLEXICON nounguess\n\nNOUNROOTGUESS   nounguessroot ;\n\n" ;
close(NGOUT);

# Create a LEXICON verbguess
# with a single entry that is nothing but a placeholder

# new 16 Oct 2000
open VGOUT, ">:utf8", "../obj/verbguess.lexc" || die "Couldn't open obj/verbguess.lexc" ;
print VGOUT "\nLEXICON verbguess\n\nVERBROOTGUESS   verbguessroot ;\n\n" ;
close(VGOUT);

        # for the guesser FST (guesses unknown noun/verb roots): 
        #     1. filter out all strings that DO NOT contain 
        #        Multichar_Symbol NOUNROOTGUESS or VERBROOTGUESS
        #     2. then replace NOUNROOTGUESS and VERBROOTGUESS with network from 
        #            src/dic/rootsguess/rootsguess.script
        #
        # for the normal FST (based on roots in the dictionary)
        #     1. filter out all strings that DO contain
        #            Multichar_Symbol NOUNROOTGUESS or VERBROOTGUESS

&do_one_line_lex("nounguessroot",
		 "^ER[nounguess]:0", "ncommon_branch", "") ;  # new 16 Oct 2000

&do_one_line_lex("verbguessroot",
		 "^ER[verbguess]:0", "vI1", "") ;      # new 16 Oct 2000

# the LEXICON Root will branch to all the basic cat entries in roots.xml
# e.g.

# LEXICON adjective
# foo     adjectiveroot ;
# bar     adjectiveroot ;

# N.B. that the continuation class is "adjectiveroot" or "daynameroot", etc.

# create "adjectiveroot" etc. LEXICONs that add an upper-side tag showing
# the part of speech of the root

&do_one_line_lex("adjectiveroot", 
		 "^ER[adjective]:0", "ncommon_branch", "") ;

&do_one_line_lex("daynameroot", 
	  "^ER[dayname]:0", "end", "HVY:179") ;

# digits are incompatible with personal possessive pronouns? look for the page ref.

&do_one_line_lex("digitroot",
	  "^ER[digit]\@P.nIPersPoss.BLOCK\@:\@P.nIPersPoss.BLOCK\@",
	  "ncommon_branch", "HVY:174-7\\nno pers poss;\\n(ni)(ki)(wa)\\nand mpi(xa) OK\\n") ;

&do_one_line_lex("interrogativeroot",
	  "^ER[interrogative]:0", "ncommon_branch", "HVY:83-85 185") ;

&do_one_line_lex("monthnameroot",
	  "^ER[monthname]:0", "end", "HVY:180") ;

&do_one_line_lex("multiplierroot",
	  "^ER[multiplier]:0", "ncommon_branch", "HVY:175") ;

&do_one_line_lex("ncommonroot",
	  "^ER[ncommon]:0", "ncommon_branch", "HVY:80 172-3") ;

&do_one_line_lex("negativeroot",
	  "^ER[negative]:0", "nIIjama", "jani HVY:83 189\\ntakes jama,\\nindep, oracional") ;

# HVY:282 shows a proper noun being verbalized; there may not
# be much difference between proper nouns and common nouns

&do_one_line_lex("nproperroot",
	  "^ER[nproper]:0", "ncommon_branch", "HVY:80 172-3") ;

&do_one_line_lex("ntemporalroot",
	  "^ER[ntemporal]:0", "ncommon_branch", "") ;

&do_one_line_lex("positionalroot",
	  "^ER[positional]:0", "positional_branch", "HVY:174 252\\ntakes na and naka\\nchiqa also takes pta") ;

&dobranch("positional_branch",
	  "nIIcaseNa",
	  "end") ;

&do_one_line_lex("positionaldefectiveroot",
	  "^ER[positionaldefective]\@P.nIPersPoss.BLOCK\@:\@P.nIPersPoss.BLOCK\@", "end", "HVY:252 259") ;

# demonstrative pronouns cannot co-occur with personal possessive
# pronouns but can take nIni

&do_one_line_lex("pronoundemonstrativeroot",
	  "^ER[pronoundemonstrative]\@P.nIPersPoss.BLOCK\@:\@P.nIPersPoss.BLOCK\@", "ncommon_branch", "HVY:40 80 182-4\\ntakes sa and kata\\nand N2Vlength") ; 


# personal pronouns cannot co-occur with nIni or with personal possessive endings

&do_one_line_lex("pronounpersonalroot",
	  "^ER[pronounpersonal]\@P.nIPersPoss.BLOCK\@\@P.nIni.BLOCK\@:\@P.nIPersPoss.BLOCK\@\@P.nIni.BLOCK\@", "n_branch", "HVY:80 182\\ntakes naka, ni;\\nnot pers poss") ;

&do_one_line_lex("verbroot",
	  "^ER[verb]:0", "vI1", "") ;


#################################################################

# need to list the multicharacter symbols used; some are wired-in
# here and others are added automatically from the information
# in the dictionary entries.  (later sort and uniq it from the Makefile)

print MCOUT "^ER\n" ;         # marks the end of a root from the basic lexicon
                              # may be necessary to find the gloss (used already?)

print MCOUT "[adjective]\n" ;
print MCOUT "[dayname]\n" ;
print MCOUT "[digit]\n" ;
print MCOUT "[interrogative]\n" ;
print MCOUT "[monthname]\n" ;
print MCOUT "[multiplier]\n" ;
print MCOUT "[ncommon]\n" ;
print MCOUT "[negative]\n" ;
print MCOUT "[nproper]\n" ;
print MCOUT "[ntemporal]\n" ;
print MCOUT "[positional]\n" ;
print MCOUT "[positionaldefective]\n" ;

print MCOUT "[pronoundemonstrative]\n" ;
print MCOUT "\@P.nIPersPoss.BLOCK\@\n" ;

print MCOUT "[pronounpersonal]\n" ;
print MCOUT "\@P.nIni.BLOCK\@\n" ;

print MCOUT "[verb]\n" ;

print MCOUT "NOUNROOTGUESS\n" ;
print MCOUT "VERBROOTGUESS\n" ;
print MCOUT "[nounguess]\n" ;
print MCOUT "[verbguess]\n" ;

print MCOUT "[voweldrop]\n" ;    # on end of word upper-side
                                #   --for allowing/controlling final vowel deletion
print MCOUT "^FVD\n" ;           # on end of word lower-side, for final vowel-deletion

print MCOUT "^Z\n" ;            # for zero complement marking (temp--use for study then
                                # quick delete before other rules apply

# tags marking morphophonological behavior

#    on the beginning (left) of suffixes

print MCOUT "^L\n" ;                 # marks suffix that lengthens a previous vowel
                                     #   these also always require a previous vowel
print MCOUT "^V\n" ;                 # marks a suffix that "requires a previous vowel"
                                     #   called "weak" in Ross
print MCOUT "^C\n" ;                 # marks a suffix that "requires a prev. consonant"
                                     #   so deletes a previous short vowel; optionally
                                     #   shortens a previous lengthened vowel
print MCOUT "^LAYKU\n" ;             # for the "layku"-like suffixes
print MCOUT "^N\n" ;                 # marks a suffix that in itself does not affect
                                     #   the previous vowel--these are "oracional"
                                     #   suffixes (two oracional suffixes are ^V)

#    on the end (right end) of suffixes
#    basically a marker on the final vowel of the suffix itself

print MCOUT "^S\n" ;                 # marks a strong final vowel; 
                                     # ^Dta^S  is the 2P Simple
                                     #   the final vowel is strong or hard

print MCOUT "^W\n" ;                 # marks a weak final vowel: ^Dta^W is the 1P Simple
                                     #   the final vowel always disappears if ANY suffix
                                     #   follows

print MCOUT "^J\n" ;        # just on the +wja-^Jita combination

# neutral final vowels of suffixes are unmarked--they stay or go depending
# mainly on whether the following suffix is weak or strong

# keep an eye on this one
print MCOUT "^IN\n" ;                # used only on indirect imperative suff -^Zpa^IN
                                     # usually becomes n except deletes before ti suffix

print MCOUT "^NeedA\n" ;               # for sequence ... a ^L ^NeedA where this is the
                                     # alt form of 1P pers poss (which lengthens the prev
                                     # vowel, but is valid only if the prev vowel is /a/

# keep an eye on this one
# print MCOUT "^A\n" ;                 # used for the euphonic vowel  SUSPECT

print MCOUT "^YA\n" ;                  # for Ross vII4 waya that has free variation with wa
                                     # but only if the following morpheme "requires
                                     # a preceding vowel"

print MCOUT "^LENGTHVSYA\n" ;          # for the phonologically conditioned N2V ^L vs ya, e.g.
                                     # warmiyä vs  *warmi::

print MCOUT "^Z\n" ;                 # on surface side of lexicon fst, ^Z marks the zero
                                     # complement morpheme

# multicharacter symbol on "end" LEXICON
print MCOUT "\@D.NeedKa@\n" ;



#################################################################

# New Mar 1 nouns start here

# common nouns (the basic starting point for any nouns)

&dobranch("ncommon_branch",
          "nIsa",
          "nIitu",
          "nIchAPPOSa",
          "nIrara",
          "N2Vcha") ;

&dosuff("nIsa", "nIsa", "n_branch", "opt", "(c)sa\\nrare, flag-controlled", "HVY:76 84 173 178 201", "", "") ;
&dosuff("nIitu", "nIitu", "n_branch", "req", "(c)itu", "HVY:198, 74", "", "") ;
&dosuff("nIchAPPOSa", "nIchAPPOSa", "n_branch", "req", "(c)ch'a\\nrare, flag-controlled", "HVY:84 184 188 198", "", "") ;
&dosuff("nIrara", "nIrara", "n_branch", "req", "(v)rara\\nrare, flag-controlled\\nblocks naka and pers poss", "", "", "") ;

&dosuff("N2Vcha", "N2Vcha", "vI2", "req", "(v)cha", "", "", "") ;

# before this n_branch the suffixes appear very limited (and are often
# controlled by Flag Diacritic; this n_branch may be the best starting
# point for many noun-like roots and nominalizations

&dobranch("n_branch",
	  "nIkata",
	  "nInaka") ;

&dosuff("nIkata", "nIkata", "star_branch", "opt", "(c)kata\\n(c)kati\\nrare and\\nflag-controlled", "HVY:76, 173, 201", "", "") ;

&dosuff("nInaka", "nInaka", "nIni", "opt", "(v)naka\\ncan precede\\nni HVY:203\\nsee NInaka-bis", "HVY:197, 206-7", "", "") ;
&dosuff("nIni", "nIni", "star_branch", "req", "(v)ni\\nposesor/enumerador\\nno co-occur w/\\nwja or jita", "HVY:76, 176-7, 203", "", "") ;  # req if this path is followed

&dobranch("star_branch",
	  "nIlxa",
	  "nIxa",
	  "nIwja-jita",
	  "nIPersPoss",
	  "nInaka-bis",
	  "pre_mpi_branch") ;

&dosuff("nIlxa", "nIlxa", "star_branch", "req", ":xa", "HVY:76, 201, 203", "backedge", "") ;
&dosuff("nIxa", "nIxa", "star_branch", "req", "(c)xa\\nencima/sobre/\\nacerca de", "HVY:76, 201-2", "backedge", "") ;
&dosuff("nIwja-jita", "nIwja-jita", "star_branch", "req", "(v)wja (c)^Jita", "HVY:76, 201", "backedge", "") ;
&dosuff("nIPersPoss", "nIPersPoss", "star_branch", "req", "(v)xa/(v)ja\\n(v)ma\\n(v)pa\\n(v)sa", "HVY:205\\nonly nouns\\ntemporals, positionals\\nand corresp interrog", "backedge", "") ;
&dosuff("nInaka-bis", "nInaka", "star_branch", "req", "(v)naka", "HVY:76, 197, 206-7", "backedge", "") ;  # reuse nInaka.xml

&dobranch("pre_mpi_branch",
	  "nImpi",
	  "nIpacha",
	  "case_branch") ;

&dosuff("nImpi", "nImpi", "post_mpi_branch", "req", "(v)mpi conjunctor\\nincompat with mpi2", "HVY:76, 197, 207, 242", "", "") ;

&dobranch("post_mpi_branch",
	  "nImpi-lxa",
	  "nImpi-xa",
	  "pre_pacha_branch") ;

&dosuff("nImpi-lxa", "nImpi-lxa", "post_mpi_branch", "req", ":xa cannot sep.\\nmpi and pacha", "HVY:197 203", "backedge", "") ;
&dosuff("nImpi-xa", "nIxa", "post_mpi_branch", "req", "(c)xa\\ncan sep.\\nmpi and pacha", "HVY:197", "backedge", "") ;

&dobranch("pre_pacha_branch",
	  "nIpacha",
	  "case_branch");

&dosuff("nIpacha", "nIpacha", "post_pacha_branch", "req", "(c)pacha inclusor", "HVY:76 197, 209", "", "");

&dobranch("post_pacha_branch",
	  "nIpacha-lxa",
	  "nIpacha-xa",
	  "case_branch") ;

&dosuff("nIpacha-lxa", "nIlxa", "post_pacha_branch", "req", "", "", "backedge", "") ; # reuse nIlxa.xml
&dosuff("nIpacha-xa", "nIxa", "post_pacha_branch", "req", "", "", "backedge", "") ;   # reuse nIxa.xml

&dobranch("case_branch",
	  "nIIcase",
	  "nIIcaseNa",
	  "nIIcaseNama");

&dosuff("nIIcase", "nIIcase", "post_case_branch", "opt", "(v)ru to/al HVY:87 196 210\\n(v)ta(c) de/desde HVY:214-7\\n(v)taki para HVY:87 161 193 196\\n(v)mpi con HVY:196 221-4\\n(layku)layku\\n'a causa de'\\nHVY:113 177 199 242 252\\n(layku)pura HVY:199-200 76-77 242", "HVY:74 76 108 185 210 242 199", "", "") ;

&dosuff("nIIcaseNa", "nIIcaseNa", "nIIcaseNa_branch", "req", "(v)na(c) de/posesion/en\\nbut (v)na before ki", "HVY:74 87 224 241", "", "") ;

&dobranch("nIIcaseNa_branch",
	  "post_case_branch",
	  "N2Vka") ;

# HVY:271 says that indep suffixes can come right after +na-ka, but
# I suspect that they are the normal indep suffixes that appear on
# any verb (here a verbalized tema)
&dosuff("N2Vka", "N2Vka", "vI8backbranch", "req", "(c)ka", "HVY:89 162, 235-8", "backedge", "HVY:162") ;

&dobackbranch("vI8backbranch",
	  "vI8") ;

# the continuation to indep_n is a reasonable guess
&dosuff("nIIcaseNama", "nIIcaseNama", "indep_n", "req", "(c)nama  a traves de\\nfossilized +na-jama", "HVY:230", "", "") ;

&dobranch("post_case_branch",
	"nIIkama",
	"nIIpacha") ;

&dosuff("nIIkama", "nIIkama", "nIIjama", "opt", "(layku)kama\\nhasta/mientras/entre\\ntodo/cada uno", "HVY:77 199 206 228 242 252-3", "", "") ;

&dosuff("nIIpacha", "nIIpacha", "indep_n", "req", "(c)pacha  (sí) mismo", "HVY:76, 209, 242, 228", "", "") ;

&dosuff("nIIjama", "nIIjama", "indep_n", "opt", "(c)jama\\n(c)ja allomorph\\n/'como'/'parecido a'", "HVY:76 88 184 230-1 271 276", "", "") ;

# almost certainly wrong here, recheck the chapters on
# indep and oracional
&dosuff("nIIzero", "nIIzero", "oracional", "req", "", "HVY:72 79 231-5", "", "") ;

&dosuff("indep_n", "indep", "indep_n_clear", "starred", "(v)ki  no mas/solo HVY:272\\n(v)puni/(v)pini emphatic HVY:273\\n(v)raki  agregador/tambien HVY:271 274", "HVY:76 88 276, 273", "", "") ;  # reuse indep.xml

&do_one_line_lex("indep_n_clear",
"\@C.INDEPpuni\@\@C.INDEPki\@\@C.INDEPraki\@", "post_indep_n_branch", "") ;

print MCOUT "\@C.INDEPpuni\@\n" ;
print MCOUT "\@C.INDEPki\@\n" ;
print MCOUT "\@C.INDEPraki\@\n" ;

&dobranch("post_indep_n_branch",
	  "nIIzero",
	  "N2Vlength",
	  "N2Vpta",
	  "oracional") ;

# HVY:271 says that indep suffixes can also come just after the N>V,
# but I think that they are the normal indep suffixes that can occur
# on any verb (here a verbalized tema)
&dosuff("N2Vlength", "N2Vlength", "vI8backbranch", "req", "", "HVY:238", "backedge", "HVY:162") ;
# check this continuation class for pta
&dosuff("N2Vpta", "N2Vpta", "vI8backbranch", "req", "(v)pta become", "HVY:89, 240, 235", "backedge", "") ;



##################################################################
# New Feb 17 starts here

# verbs  CLASS I of suffixes

&dosuff("vI1", "vI1", "vI2", "opt", "(v)cha", "HVY:97-98", "", "") ;
&dosuff("vI2", "vI2", "vI2_branch", "opt", "(c)ja", "HVY:97-98", "", "") ;

&dobranch("vI2_branch", 
	  "vI3", 
	  "vI5", 
	  "vI7", 
	  "vI9") ;

&dosuff("vI3", "vI3", "vI4", "opt", "(c)su", "HVY:97, 99, 115", "", "") ;
&dosuff("vI5", "vI5", "vI6", "opt", "(c)nuqa\\n(v)qa\\n(c)xata\\n(v)kipa", "HVY:97, 101-2\\n[KRB moved\\nkipa from v7]", "", "") ;
&dosuff("vI7", "vI7", "vI8", "opt", "(c)kata\\n(c)naqa\\n(v)nta\\n(v)nuku\\n(v)tata\\n(c)xaru\\n(c)x\fi228si\\n(c)xaya\\n(v)kipsta", "HVY:97, 103-6\\n[kipsta added\\nby KRB]", "", "") ;
&dosuff("vI9", "vI9", "vII0", "opt", "(v)rpaya", "HVY:97-107", "", "") ;  # go to the si that can precede or
                                        # follow ya vII1 (HVY:107, 121)

&dosuff("vI4", "vI4", "vI6", "opt", "(c)thapi\\n(v)ra", "HVY:97, 99-100", "", "") ;
&dosuff("vI6", "vI6", "vI8", "opt", "(c)ta", "HVY:97, 102", "", "") ;

&dosuff("vI8", "vI8", "vII0", "opt", "(c)t'a\\n(c)ch'uki", "HVY:95, 106-7", "", "") ;  # target for : and +na-ka verbalizations


# verbs  CLASS II of suffixes

# HVY:107, 121 says reflexive si can occur before or after VII1 ya
# treat this possible preceding si as vII0

&dosuff("vII0", "vII2", "vII1", "opt", "(v)si\\nreflexive", "HVY:121\\n[can precede or\\nfollow ya]", "", "") ;   # reflexive si preceding ya
                                           # create it from vII2.xml

&dosuff("vII1", "vII1", "vII1bis", "opt", "(v)ya\\ncausative", "HVY:97, 108", "", "") ;
&dosuff("vII1bis", "vII1", "vII2", "opt", "(v)ya\\ncausative", "", "", "") ;

&dosuff("vII2", "vII2", "vII3", "opt", "(v)si\\nreflexive", "HVY:97, 108-9, 121\\n[mut. excl. w/\\nrapi and raqa]", "", "") ;   # reflexive si following ya

&dosuff("vII3", "vII3", "vII4", "opt", "(v)ni\naproximador", "HVY:97, 109", "", "") ;
&dosuff("vII4", "vII4", "vII5", "opt", "(v)waya\n(var. wa)", "distanciador\\nHVY:97, 109\\n231, 240, 266-68", "", "") ;
&dosuff("vII5", "vII5", "vII6", "opt", "(v)rapi (ben.)\\n(v)raqa (vic.)", "HVY:87, 109-10\\n[mut. excl. w/ refl. si]", "", "") ;
&dosuff("vII6", "vII6", "vII7", "opt", "(v)si\\ncontinuativo", "HVY:97, 111, 121\\n[_can_ do-occur\\nsomehow w/ xa\\nbut (usually?)\\nneeds following\\nka, perhaps\\nafter +p]]", "", "") ;
&dosuff("vII7", "vII7", "vII8", "opt", "(c)ka\\nadelantador\\nimperfective", "HVY:97, 111", "", "") ;
&dosuff("vII8", "vII8", "vII8_branch", "opt", "(c)xa\\nperfective", "HVY:97, 111\\n[can co-occur with\\nka adelantador", "", "") ;

&dobranch("vII8_branch", 
	  "vII9",             # this is the p plural, which then requires
                              # a following xa or ka
	  "vSubGeneral", 
	  "indep_v") ;

&dosuff("vII9", "vII9", "vII10", "req", "(v)p\\nplural", "HVY:97, 112\\n[must be followed\\nby ka or xa]", "", "") ;           # required (on this path)
&dosuff("vII10", "vII10", "vII10_branch", "req", "(c)ka [imperf]\\n(c)xa [perf]", "", "", "") ;  # required after p

&dobranch("vII10_branch", 
	  "vSubGeneral", 
	  "indep_v") ;

&dosuff("vSubGeneral", "vSubGeneral", "oracional", "req", "(v)sa(v)\\n(v)sina(c)\\n(c)ipana(c)", "HVY:160-1", "", "") ;  # CC is a guess
&dosuff("indep_v", "indep", "indep_v_clear", "starred", "(v)ki\\n(v)puni/(v)pini\\n(v)raki", "HVY:76, 88, 273, 276, 271", "", "") ;    # indep.xml will
                                                             #  be reused
       # all the indeps can occur together, in any order; flags block
       # duplication (a guess at a restriction)

       # clear the feature restrictions here
&do_one_line_lex("indep_v_clear", 
"\@C.INDEPki\@\@C.INDEPpuni\@\@C.INDEPraki\@", "indep_v_branch", "") ;


&dobranch("indep_v_branch", 
	  "nominalizers", 
	  "flexions") ;

&dobranch("nominalizers", 
	  "V2Niri2",    # this is the "in order to" suffix
	  "V2Nwi", 
	  "V2Niri1", 
	  "V2Nta", 
	  "V2NnTILDEa") ;

&dosuff("V2Niri2", "V2Niri2", "indep_n", "req", "(c)iri\\nin order to", "HVY:71, 161, 192", "backedge", "") ;

&dosuff("V2Nwi", "V2Nwi", "n_branchcollect", "req", "(v)wi\\nplace/occasion", "HVY:267-8, 195", "backedge", "") ;
                   # send V2Nwi to n_branch for now (restrict later?)
&dosuff("V2Niri1", "V2Niri1", "n_branchcollect", "req", "(c)iri\\none who", "HVY:190-1", "backedge", "") ;
                   # send V2Niri1 to n_branch for now (restrict later?)

# the following two can obviously take lots of noun suffixes
&dosuff("V2Nta", "V2Nta", "n_branchcollect", "req", "(v)ta(v)\\nresult", "HVY:195, 239", "backedge", "") ;
&dosuff("V2NnTILDEa", "V2NnTILDEa", "n_branchcollect", "req", "(v)\fi241a\\ninfinitive", "HVY:240 161 190-4", "backedge", "") ;

&dobackbranch("n_branchcollect",
	      "n_branch") ;

&dobranch("flexions",

	  "vFlexPacha", 
	  "vFlexChi",

	  "vFlexSimple", 
	  "vFlexFuturo", 
	  "vFlexRemCerc",
	  "vFlexRemLej", 
	  "vFlexReprochador", 
	  "vFlexImperative",
	  "vFlexDesiderativo") ;


&dosuff("vFlexPacha", "vFlexPacha", "vFlexPacha_branch", "req", "(c)pacha inferencial", "HVY:87", "", "") ;
&dobranch("vFlexPacha_branch",
	  "vFlexLengthen4Simple", # lengthen pacha to pacha: before
	                          # attaching Simple endings
	  "vFlexFuturo",      # but go straight from pacha to Future
	  "vFlexRemCerc") ;   # and go straight from pacha to RemCerc

&dosuff("vFlexLengthen4Simple", "vFlexLengthen4Simple", "vFlexSimple", "req", ":", "", "", "") ;

&dosuff("vFlexChi", "vFlexChi", "vFlexChi_branch", "req", "chi no-involucrador", "HVY:87", "", "") ;
&dobranch("vFlexChi_branch", 
	  "vFlexSimple", 
	  "vFlexFuturo", 
	  "vFlexRemCerc",
	  "vFlexRemLej", 
	  "vFlexReprochador", 
#	  "vFlexImperative",  I don't think that chi goes to imperatives
	  "vFlexChiDesiderativo") ;  # special Des. endings after chi

# idiosyncratic Desiderative endings after chi
&dosuff("vFlexChiDesiderativo", "vFlexChiDesiderativo", "oracional", "req", "", "HVY:88", "", "") ;

&dosuff("vFlexSimple", "vFlexSimple", "oracional", "req", "", "", "", "") ;
&dosuff("vFlexFuturo", "vFlexFuturo", "oracional", "req", "", "", "", "") ;
&dosuff("vFlexRemCerc", "vFlexRemCerc", "oracional", "req", "", "", "", "") ;
&dosuff("vFlexRemLej", "vFlexRemLej", "oracional", "req", "", "", "", "") ;
&dosuff("vFlexReprochador", "vFlexReprochador", "oracional", "req", "", "", "", "") ;
&dosuff("vFlexImperative", "vFlexImperative", "oracional", "req", "", "", "", "") ;
&dosuff("vFlexDesiderativo", "vFlexDesiderativo", "oracional", "req", "", "", "", "") ;




# oracional/sentential
&dobranch("oracional", 
	  "or1", 
	  "or1stixa", 
	  "or1ti", 
	  "or1chi") ;

&dosuff("or1", "or1", "or2", "opt", "(n)wa affirm/absoluto HVY:280\\n(n)sa1 info. quest. HVY281\\n(n)sa2 agregador HVY:285-6\\n(n)cha interr. alt. HVY:286\\n(n)pi por_supuesto HVY:286", "", "", "") ;
&dosuff("or1stixa", "orstixa", "or2", "req", "(n)xa atenuador/topic\\n(n)sti refer HBY:284-5\\nreused for or2stixa", "", "", "") ;   # orstixa reused below
&dosuff("or1ti", "or1ti", "or1ti_branch", "req", "", "", "", "") ;
&dosuff("or1chi", "or1chi", "or2mxa", "req", "(n)chi suposicional", "HVY:287", "", "") ;

&dobranch("or1ti_branch", 
	  "or2", 
	  "or2stixa") ;

&dosuff("or2", "or2", "end", "opt", ": exclamatorio HVY:287-8\\n(v)ya cortesia HVY:284", "", "", "") ;
&dosuff("or2stixa", "orstixa", "end", "opt", "(n)sti\\n(n)xa", "", "", "") ;  # orstixa reused here
&dosuff("or2mxa", "or2mxa", "end", "req", "(v)m\\n(v)xa", "", "", "") ;

&dosuff("end", "end", "featcheck", "opt", "", "", "", "");

# featcheck (final check for "required features" at end of word
&do_one_line_lex("featcheck", 
	  "\@D.NeedKa\@", "#", "") ;
# make sure that any "Need" feature for ka (aspect) is satisfied
# see vII10.xml vII6.xml vII7.xml

# add node: for # to VCG file

print VCGOUT "\nnode: {\ntitle:\"#\"\n}\n" ;

# add closing brace to VCG file


# create a copyright node

print VCGOUT "node:{\ntitle:\"copyright_notice\"\nlabel:\"Aymara Morphotactic Chart\\nKenneth R. Beesley\\nXerox Research Centre Europe\\nhttp://www.xrce.xerox.com/research/mltt/aymara\\nCopyright \\fi169 2000 Xerox Corporation\\nAll Rights Reserved\"\nvertical_order:37\nshape:box\n}\n";

print VCGOUT "\n}\n" ;


##################################################################

sub do_one_line_lex {
  if (@_ ne 4) {
    print STDERR "Error in number of args to do_one_line_lex" ;
  }

  my($lname, $dstring, $ccstring, $charttext) = @_ ;

  print LEXCOUT "\nLEXICON $lname" ;
  print LEXCOUT "\n$dstring\t $ccstring ;\n" ;

  if ($charttext ne "") {
    print VCGOUT "\nnode: {\ntitle:\"$lname\"\nlabel:\"$lname\\n$charttext\"\n}\n" ;
  } else {
    print VCGOUT "\nnode: {\ntitle:\"$lname\"\n}\n" ;
  }

  print VCGOUT "\nedge: {\nsourcename:\"$lname\"" ;
  print VCGOUT "\ntargetname:\"$ccstring\"\n}\n" ;

}


sub dobranch {
  my $vertical_order = "" ;
  my $lexname = shift ;
  print LEXCOUT "\nLEXICON $lexname\n" ;

  if ($lexname eq "Root") {
    $vertical_order = "0" ;
  }


  print VCGOUT "\nnode: {\ntitle:\"$lexname\"\nlabel:\"$lexname\"\nshape:ellipse" ;
  if ($vertical_order ne "") {
    print VCGOUT "\nvertical_order:$vertical_order" ;
  }
  print VCGOUT "\n}\n" ;

  foreach my $l (@_) {
    print LEXCOUT "\t $l ;\n" ;


    print VCGOUT "\nedge: {\nsourcename:\"$lexname\"\ntargetname:\"$l\"\n}\n" ;

    if ($lexname eq "Root") {
      print VCGOUT "\nnode:\n{\ntitle:\"$l\"\n}\n" ;

      print VCGOUT "\nedge:\n{\nsourcename:\"$l\"" ;
      print VCGOUT "\ntargetname:\"$l", "root\"\n}\n" ;
    }

  }
}

# backbranch like branch except collects backlinks for cleaner chart
# usually just one backlink from the backbranch
sub dobackbranch {
  my $vertical_order = "" ;
  my $lexname = shift ;
  print LEXCOUT "\nLEXICON $lexname\n" ;

#  if ($lexname eq "Root") {
#    $vertical_order = "0" ;
#  }


  print VCGOUT "\nnode: {\ntitle:\"$lexname\"\nlabel:\"$lexname\"\nshape:ellipse" ;
  if ($vertical_order ne "") {
    print VCGOUT "\nvertical_order:$vertical_order" ;
  }
  print VCGOUT "\n}\n" ;

  foreach my $l (@_) {
    print LEXCOUT "\t $l ;\n" ;


    print VCGOUT "\nbackedge: {\nsourcename:\"$lexname\"\ntargetname:\"$l\"\nlinestyle:dashed\npriority:0\n}\n" ;

#    if ($lexname eq "Root") {
#      print VCGOUT "\nnode:\n{\ntitle:\"$l\"\n}\n" ;
#
#      print VCGOUT "\nedge:\n{\nsourcename:\"$l\"" ;
#      print VCGOUT "\ntargetname:\"$l", "root\"\n}\n" ;
#    }

  }
}

my $lexiconname ;       # the name of the lexc LEXICON to create, usually
                        # the same as the filename unless copying
my $filename ;          # the xml file to read from

my $cc ;
my $cat ;

my $lextext ;
my $surftext ;

my $upperside ;
my $lowerside ;

my $left ;              # the left attr of the suffix (tells how the suffix
                        #   affects the last vowel of the previous suffix)
my $right ;             # the right attr of the suffix (tells how the final
                        #   vowel of the suffix acts morphophonologically)

my $sepupper ;          # a multichar symbol used to encode the $left attr
my $seplower ;

my $finalvowelupper ;        # a multichar symbol used to encode the $right attr
my $finalvowellower ;

my $glossesStr ;
my $glosasStr ;
my $gloss ;             # Latin1 in xml, XML::Parser returns utf8, 
                        # first stored in $gloss as 16-bit Unicode, then as latin1

my $features ;
my $feature ;

my $req ;

my $nameinxml ;         # name attr in the xml file itself

my $chart_label ;

my $refs ;

my $edgetype ;
my $edgelabel ;

my $vcg_node_label ;


sub dosuff {
  if (@_ != 8) {
    die "Usage: dosuff <lexiconname> <xmlfilename> <cc> <opt|req|starred> <chart_label> <refs> <edgetype> <edgelabel>" ;
  }

  # the <edgetype> is either "", or "backedge" (used for compounding loops or
  #         derivational linkbacks

  # the <edgelabel> is not used now (see below)

  # store the various arguments in variables

  ($lexiconname, $filename, $cc, $req, $chart_label, $refs, $edgetype, $edgelabel) = @_ ;

  # limited values for the $req variable

  if ($req ne "opt" && $req ne "req" && $req ne "starred") {
    die "Bad optionality arg to dosuff: $lexiconname, $filename, $cc, $req" ;
  }

  print STDERR "  Downtranslating $lexiconname: " ;

  # a single XML file can be used multiple times to create separate LEXICONs in the
  #   lexc file
  if ($filename ne $lexiconname) {
    print STDERR "\nIndicates copying of $filename.xml info to LEXICON $lexiconname\n" ;
  }

  # output for the visual (VCG) graph
  print VCGOUT "\nnode: {\ntitle:\"$lexiconname\"\n" ;
  
  # use the lexiconname by default as the VCG node label
  $vcg_node_label = $lexiconname ;
  if ($chart_label ne "") {
    $vcg_node_label .= "\\n" . $chart_label ;
  }
  if ($refs ne "") {
    $vcg_node_label .= "\\n" . $refs ;
  }
  print VCGOUT "label:\"$vcg_node_label\"" ;

  my $s = "" ;
  # choose shape of VCG node depending on whether the suffix class is required
  if ($req eq "opt" || $req eq "starred") {
    $s = "rhomb" ;
  } else {
    $s = "box" ;
  }

  print VCGOUT "\nshape:$s\n}\n" ;

  # backedges get 0 priority in the chart building, so they tend to point
  #  backwards as necessary to reach their goal
  if ($edgetype eq "backedge") {
    print VCGOUT "\nbackedge: {\nsourcename:\"$lexiconname\"" ;
  } else {
    print VCGOUT "\nedge: {\nsourcename:\"$lexiconname\"" ;
  }

  print VCGOUT "\ntargetname:\"$cc\"" ;

  if ($edgetype eq "backedge") {
    print VCGOUT "\nlinestyle:dashed" ;
    print VCGOUT "\npriority:0" ;
  }

  # edgelabels are not being used right now

#  if ($edgelabel ne "") {
#    print VCGOUT "\nedgelabel:\"$edgelabel\"" ;
#  }

  print VCGOUT "\n}\n" ;

  # for starred node, create an exit arc that loops to the
  # same node

  if ($req eq "starred") {
    print VCGOUT "\nbackedge: {\nsourcename:\"$lexiconname\"" ;
    print VCGOUT "\ntargetname:\"$lexiconname\"\nlinestyle:dashed\n}\n" ;
  }

  # invoke the XML::Twig parser here, to build the lexc file

  eval { $parser->parsefile("$suffdicsdir/" . $filename . ".xml") ; } ;

  if ($@) {
      print STDERR "\n\n*************************\n" ;
      print STDERR "\nParse error: $@\n" ;
      print STDERR "\n    while parsing suffix file: $filename\n" ;
  } else {
      print STDERR "Normal termination.\n" ;
  }
}


###############################################################################

sub suffdict_handler {
    (my $t, my $suffdict) = @_ ;

    my $suffdictname = $suffdict->att('name') ;

    if ($suffdictname != $filename) {
	print STDERR "\n\nError in name of $filename xml file\n" ;
	print STDERR "Value of name is $suffdictname\n" ;
	
    }
    # print out the LEXICON header to the lexc file
    print LEXCOUT "\n\nLEXICON $lexiconname\n" ;

    my @entries = $suffdict->children('entry') ;

    foreach my $entry (@entries) {

	$glossesStr = "" ;
	$features = "" ;

	$upperside = "" ;    # upperside of a lexc entry (line)
	$lowerside = "" ;    # lowerside of a lexc entry (line)

	$lextext = "" ;      # holds the (morpho)phonological material
	$surftext = "" ;

	# the <lex> element must be present; it specifies the
	#   lexical form and morphophonological attributes
        # by default, the surface string is the same

	my $lex = $entry->first_child('lex') ;
	
	$left = $lex->att('left') ;  
        # l, v, c , layku or n
        # marks the effect of the suffix on the final vowel
        # of the preceding suffix
	if ($left eq "l") {
	    $sepupper = "^L" ;   # this suffix lengthens the previous vowel
	} elsif ($left eq "v") {
	    $sepupper = "^V" ;   # this suffix "requires a preceding vowel"
	} elsif ($left eq "c") {
	    $sepupper = "^C" ;   # this suffix "requires a preceding consonant" SO
	    #    deletes the preceding vowel (or optionally
	    #    shortens a preceding lengthened vowel)
	} elsif ($left eq "layku") {
	    $sepupper = "^LAYKU" ;  # more complicated morphophonology for this one
	} elsif ($left eq "n") {
	    $sepupper = "^N" ;      # neutral--no effect on previous vowel
	    #    most "oracional" suffixes are marked this way
	} else {
	    print STDERR "Error in left attr in entry for file: $filename\n" ;
	}

	$right = $lex->att('right') ;
	if (!defined($right)) {
	    $right = "n" ;
	}
        # v, c or n
        # marks the behavior of the final vowel of the
        # current suffix; most (default) are n
	if ($right eq "c") {
	    $finalvowelupper = "^W" ;  # weak final vowel, disappears if ANY suffix
	    #   follows, like 1P Simple  ^Cta^W
	} elsif ($right eq "v") {
	    $finalvowelupper = "^S" ;  # strong final vowel, like 2P Simple  ^Cta^S
	} elsif ($right eq "n") {
	    $finalvowelupper = "" ;    # neutral--stays or deletes depending mostly on
	    #     whether the next suffix is weak or strong
	    #     or responding to sentence-level influences;
	    # no marking (empty string)
	} else {
	    print STDERR "Error in right attr in entry for file: $filename\n" ;
	}

	$lextext = NFC($lex->trimmed_text) ;

	$upperside .= $sepupper ;     # the morpheme separator, e.g. ^C or ^V

	$upperside .= $lextext ;	# typically phonological material

	$upperside .= $finalvowelupper ; # i.e. weak or strong final vowel

	###############################################################
	#  the <surf> element is optional
	###############################################################

	my $surf = $entry->first_child('surf') ;

	if (!defined($surf)) {
	    $lowerside = $upperside ;
	} else {
	    # handle the attributes on the <surf> start tag, e.g. <surf left="l">

	    # other possibilities now for surf left="z" (for zero complement) and
	    # left="fvd" for final vowel dropping

	    $left = $surf->att('left') ;
	    # l, v, c , layku, n, z, fvd
	    # marks the effect of the suffix on the final vowel
	    # of the preceding suffix
	    if ($left eq "l") {
		$seplower = "^L" ;           # this suffix lengthens the previous vowel
	    } elsif ($left eq "v") {
		$seplower = "^V" ;           # this suffix "requires a preceding vowel"
	    } elsif ($left eq "c") {
		$seplower = "^C" ;           # this suffix "requires a preceding consonant" SO
		#    deletes the preceding vowel (or optionally
		#    shortens a preceding lengthened vowel)
	    } elsif ($left eq "layku") {
		$seplower = "^LAYKU" ;       # more complicated morphophonology for this one
	    } elsif ($left eq "n") {
		$seplower = "^N" ;           # neutral--no effect on previous vowel
		#    most "oracional" suffixes are marked this way
	    } elsif ($left eq "z") {
		$seplower = "^Z" ;
	    } elsif ($left eq "fvd") {
		$seplower = "^FVD" ;
	    } else {
		print STDERR "Error in left attr encoding for surf element in file $filename\n" ;
	    }

	    $right = $surf->att('right') ;
	    # v, c or n
	    # marks the behavior of the final vowel of the
	    # current suffix

	    if (!defined($right)) {
		$right = "n" ;   # default
	    }

	    if ($right eq "c") {
		$finalvowellower = "^W" ;    # weak final vowel, disappears if ANY suffix
		#   follows, like 1P Simple  ^Cta^W
	    } elsif ($right eq "v") {
		$finalvowellower = "^S" ;    # strong final vowel, like 2P Simple  ^Cta^S
	    } elsif ($right eq "n") {
		$finalvowellower = "" ;      # neutral--stays or deletes depending mostly on
		#     whether the next suffix is weak or strong
		#     or responding to sentence-level influences;
		# no marking (empty string)
	    } else {
		print STDERR "Error in right attr encoding for surf element in file $filename\n" ;
	    }

	    $surftext = NFC($surf->trimmed_text) ;

	    $lowerside .= $seplower ;     # can now be "none", resulting in $seplower eq ""
	    
	    $lowerside .= $surftext ;	# typically phonological material
	    
	    if ($finalvowellower eq "") {	# then inherit from upperside
		$lowerside .= $finalvowelupper ; # i.e. weak or strong final vowel
	    } else {
		$lowerside .= $finalvowellower ;
	    }
	}

	####################################################################
	#  handle glosses
	####################################################################

	my $glossesElmt = $entry->first_child('glosses') ;

	my $eng_glossElmt = $glossesElmt->first_child('english') ;
	my @glossElmts = $eng_glossElmt->children('gloss') ;
	$glossesStr = "" ;
	foreach my $glossElmt (@glossElmts) {
	    my $glossStr = NFC($glossElmt->trimmed_text) ;
	    $glossStr =~ s/ /_/g ;
	    if ($glossesStr ne "") {
		$glossesStr .= "/" ;
	    }
	    $glossesStr .= $glossStr ;
	}

	my $spn_glossElmt = $glossesElmt->first_child('spanish') ;
	my @glosaElmts =  $spn_glossElmt->children('glosa') ;
	$glosasStr = "" ;
	foreach my $glosaElmt (@glosaElmts) {
	    my $glosaStr = NFC($glosaElmt->trimmed_text) ;
	    $glosaStr =~ s/ /_/g ;
	    if ($glosasStr ne "") {
		$glosasStr .= "/" ;
	    }
	    $glosasStr .= $glosaStr ;
	}

	# just use the English $glossesStr for now? as "suffix tags" (multichar)

	####################################################################
	#  handle any features
	####################################################################
	

	my $featuresElmt = $entry->first_child('features') ;

	if (defined($featuresElmt)) {
	    my @features = $featuresElmt->children('feature') ;

	    foreach my $feature (@features) {
		my $flag_diacritic = NFC($feature->trimmed_text) ;
		# declare it as a multichar symbol
		print MCOUT "$flag_diacritic\n" ;

		$features .= $flag_diacritic ;
	    }
	}

	####################################################################
	#  write out all the info for this entry
	####################################################################

	my $mcs = "" ;               # used to hold the glosses (with square brackets, 
	                             #     used as a lexical tag)
	my $declaredmcs = "" ;       # same (for now)

	# the (English) gloss of a suffix is here made into a Multichar_Symbol,
	# surrounded by square brackets; multiple glosses are separated by a slash
	$mcs = "[$glossesStr]" ;

	# literalize any lexc special characters (none for now?)
	$declaredmcs = $mcs ;
	print MCOUT "$declaredmcs\n" ;

	# here append the list of features collected (i.e. Flag Diacritics) to the
	# upper side
	$upperside .= $features ;
	$lowerside .= $features ;
	
	# the "mcs" (lexical tag) goes only on the upperside

	$upperside .= $mcs ; # concat common and multi-char symbols
	print LEXCOUT "$upperside:$lowerside" ; # print out with separating colon

	if ($req eq "starred") {
	    # then needs to point back to itself, i.e. the cont. class is the same LEXICON
	    print LEXCOUT "\t $lexiconname ;\n" ;
	} else {
	    # else point to the indicated continuation lexicon
	    print LEXCOUT "\t $cc ;\n" ;
	}
    }

    # end of the whole suffdict
    if ($req eq "opt" || $req eq "starred") {
	# then add an empty entry leading to the continuation class
	print LEXCOUT "\t\t$cc ;\n" ;
    }
}



